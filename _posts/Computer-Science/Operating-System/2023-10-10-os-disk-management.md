---
title: "[OS] 8. 디스크 관리"
date: 2023-10-10 16:50:00 +0900
categories: [Computer Science, Operating System]
tags: [cs, os, 운영체제, os 총정리, 디스크 스케줄링, 디스크]     # TAG names should always be lowercase
math: true
mermaid: true
image: 
  path: /assets/img/posts/Computer-Science/Operating-System/thumbnail.png
---

> 디스크(disk)는 대표적인 2차 저장장치로, 컴퓨터에서 작업한 결과를 영구 보관하기 위해 사용한다.
> 

<br>

## 1. 디스크의 구조

![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-01.png){: .w-50}

### 논리 블록 (Logical Block)
- 디스크 외부에서는 디스크를 **일정한 크기의 저장 공간**으로 이루어진 **1차원 배열처럼 취급**하는데, 이 일정한 크기의 저장 공간을 의미한다.
- 디스크에 **데이터가 저장**될 때, 디스크 외부로 **입출력**이 일어날 때 모두 **논리 블록 단위로 작업**이 수행된다.

<br>

### 섹터 (Sector)
- 데이터에 접근하기 위해서는 **해당 논리 블록의 인덱스 번호를 디스크에 전달**해야 하며, **디스크 컨트롤러**가 해당 논리 블록이 저장된 **물리적 위치(= 섹터)를 찾아** 작업을 수행하게 된다.
- **논리 블록** 하나가 **섹터** 하나로 **1:1 mapping** 된다.
- 섹터에는 **최소한의 단위 정보**가 저장된다.

<br>

### 디스크의 물리적 구조
- 하나 이상의 **마그네틱 원판(platter)**으로 이루어져 있다.
    
    > 원판(platter)은 앞/뒷면 양면으로 구성되어 있다.
    > 
- 각 원판은 **트랙(track)**으로 구성된다.
- 각 트랙(track)은 **섹터(sector)**로 나뉜다.
    
    > <span class="blue">**섹터(sector) vs. 블록(block)**</span>
    > 
    > - <https://www.geeksforgeeks.org/difference-between-page-and-block-in-operating-system/>
    > - <https://stackoverflow.com/questions/51006070/file-system-block-size-vs-disk-block-size>
    > 
    > | 구분 | 설명 | 일반적인 크기 |
    > | --- | --- | --- |
    > | **sector** | the smallest unit of information that can be read or written<br>used by disks | 512byte |
    > | **block** | the smallest logical unit of storage allocation and retrieval<br>used by file systems (하나 이상의 sectors로 구성) | 4KB |

- 여러 원판에서 상대적 위치가 동일한 트랙(track)들의 집합을 **실린더(cylinder)**라고 한다.
- 디스크에 데이터를 읽고 쓰려면 **암(arm)**이 해당 **섹터(sector)**가 위치한 **실린더(cylinder)**로 이동한 후, **원판이 회전**하여 디스크 **헤드(head)**가 저장된 **섹터(sector)** 위치에 도달해야 한다.
    
    > 디스크 헤드(head)는 암(arm)에 붙어있으며, 암(arm)은 하나의 원판(platter)에 대해 양면마다 하나씩 존재한다.
    > 

<br>

---

## 2. 디스크 스케줄링

### 디스크 접근 시간 (Access Time)

> 디스크 입출력의 효율을 높이려면 **디스크 접근 시간을 최소화**해야 한다. 특히 **탐색 시간**을 줄여야 한다!

1. **탐색 시간 (seek time)**
    - 헤드를 **해당 실린더 위치**로 이동시키는 데에 걸리는 시간이다.
    - 이를 줄이기 위해 **헤드의 움직임을 최소화** 하는 **디스크 스케줄링(disk scheduling)**을 수행한다.
2. **회전 지연 시간 (rotational latency)**
    - 디스크가 회전하여 **섹터**가 헤드 위치에 도달하기까지 걸리는 시간이다.
    - 상대적으로 수치가 작고 운영체제 입장에서 통제하기 힘들다.
3. **전송 시간 (transfer time)**
    - 해당 섹터가 헤드 위치에 도달한 후 **데이터를 실제로** 섹터에 읽고 쓰는 데에 소요되는 시간이다.
    - 상대적으로 수치가 작고 운영체제 입장에서 통제하기 힘들다.

<br>

### 디스크 스케줄링

- **여러 섹터들에 대한 입출력 요청**이 들어올 때, **효율적인 디스크 입출력**을 위해 이들을 어떠한 순서로 처리할지 결정하는 메커니즘이다.
- 가장 중요한 목표는 <span class="hl">**해당 섹터가 속하는 실린더**로의 **디스크 헤드 이동거리**를 줄여 **탐색 시간**을 줄이는 것</span>이다.

<br>

### [1] FCFS 스케줄링 (First Come First Served)

> 디스크에 먼저 들어온 요청을 먼저 처리하는 방식

- **단점**: 입출력 요청이 디스크의 양끝에 번갈아 도착한다면 매우 비효율적이다.

![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-02.jpeg){: .w-75}

<br>

### [2] SSTF 스케줄링 (Shortest Seek Time First)

> 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 방식

- 헤드의 이동 거리를 줄여 디스크 입출력의 효율성을 증가시킬 수 있으나, 이동 거리 측면에서 가장 우수한 알고리즘은 아니다.
- **단점**: 현재 헤드 위치로부터 가까운 곳에서 지속적으로 요청이 발생한다면, 헤드 위치로부터 먼 곳의 요청은 무한히 기다려야 하는 **기아 현상(starvation)**이 발생할 수 있다.

![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-03.jpeg){: .w-75}

<br>

### [3] SCAN 알고리즘 (Elevator Scheduling)

> 헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리하는 방식

- 디스크의 **어떠한 위치에 요청이 들어오는지와 상관없이**, 헤드는 **정해진 방향**으로 이동하며 그 사이에 있는 요청들을 처리한다.
- 마치 엘리베이터처럼 디스크의 한쪽 끝에 도달하면 방향을 바꾸어 다른 쪽 끝을 향해 이동한다.
    
    ![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-04.jpeg){: .w-50}
    
- **장점:** 효율성과 형평성을 모두 만족한다.
    - FCFS처럼 불필요한 헤드의 이동이 발생하거나 SSTF처럼 기아 현상이 발생하지 않는다.
    - 한 번만 이동하면 현재 큐에 들어온 모든 요청을 처리할 수 있다.
- **단점:** 가운데 위치가 안쪽 또는 바깥쪽 위치보다는 기다리는 평균 시간이 더 짧아 모든 실린더 위치에서 공평한 것은 아니다.

![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-05.jpeg){: .w-75}

<br>

### [4] C-SCAN 알고리즘 (Circular-Scan)

> SCAN 알고리즘과 비슷하지만, 헤드가 이동하는 방향이 **특정 방향일 때만** 그 사이에 존재하는 요청들을 처리하는 방식

- SCAN과 달리 헤드가 다른 쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고, **곧바로 출발점으로 다시 이동만** 한다.
    
    ![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-06.jpeg){: .w-50}
    
- **장점:** 각 실린더 위치에 대해 SCAN 보다 더 균일한 탐색 시간을 제공한다. (탐색 시간의 편차 ⬇️)
- **단점:** SCAN 보다 헤드의 이동 거리는 조금 길어진다.

![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-07.jpeg){: .w-75}

<br>

### [5] LOOK & C-LOOK 알고리즘

- **LOOK 알고리즘**: 헤드가 한쪽 방향으로 이동하다가 그 방향에 더 이상 **대기 중인 요청이 없으면 헤드의 이동 방향을 즉시 반대로** 바꾸는 방식이다.
- **C-LOOK 알고리즘**: LOOK과 유사하게 전방에 요청이 없을 때 방향을 바꾸고, C-SCAN과 유사하게 특정 방향으로 헤드를 이동할 때에만 요청을 처리하는 방식이다.

![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-08.jpeg){: .w-75}

> 디스크 입출력이 많은 시스템에서 FCFS, SSTF에 비해 SCAN, C-SCAN, LOOK, C-LOOK 등의 알고리즘이 더 효율적이다.
{: .prompt-tip}

<br>

---

## 3. 다중 디스크 환경에서의 스케줄링

> 다중 디스크를 사용하면 시스템의 성능과 신뢰성을 향상시킬 수 있다. (ex. 동시 사용자가 많은 포털 사이트 등)
> 

### 디스크 스케줄링 기법

- **단일 디스크 스케줄링**: 하나의 디스크 내에서 입출력 요청의 처리 순서를 결정한다.
- **다중 디스크 스케줄링**: 작업을 수행할 디스크를 결정하는 문제까지 포함한다.

<br>

### 다중 디스크 스케줄링의 목표

> 스케줄링의 목표에 따라 요청을 처리할 디스크를 결정하는 기준이 달라진다.

1. **탐색 시간(seek time)을 줄이는 것**
    - 여러 디스크 중 헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크를 선택한다.
2. **각 디스크 간 load balancing을 이루는 것**
    - 많은 요청을 동시에 처리할 수 있는 확장성이 중요한 경우, 일부 디스크가 과부하 상태에 이르지 않고 모든 디스크에 요청이 골고루 분배되도록 스케줄링한다.
    - ex) 그룹 엘리베이터 시스템 (다수의 승객이 오래 기다리지 않고 빠른 서비스를 받을 수 있도록 함)
3. **전력 소모를 줄이는 것**
    - 일부 디스크에 요청을 집중시키고, 나머지 디스크는 회전을 정지시킨다.
    - 요청의 빈도가 일부 디스크만으로 요청을 충분히 처리할 수 있을 정도인 상황에 한해서 적용 가능하다.
    - ex) 사용자가 적은 경우, 일부 엘리베이터에 부하를 집중시키는 부하편향 기법

<br>

---

## 4. 디스크의 저전력 관리

### [1] 비활성화 기법

- **전력 소모를 기준으로 나눈 디스크의 상태**
    - **활성 상태**: 디스크가 회전 중인 상태
        
        | 디스크 상태 | 설명 |
        | --- | --- |
        | **활동 상태** (active) | 현재 헤드가 데이터를 읽거나 쓰고 있는 상태 |
        | **공회전 상태** (idle) | 디스크가 회전 중이지만 데이터를 읽거나 쓰지는 않는 상태 |

    - **비활성 상태**: 디스크의 회전이 정지한 상태
        
        | 디스크 상태 | 설명 |
        | --- | --- |
        | **준비 상태** (standby) | 디스크가 회전하지 않지만 인터페이스가 활성화된 상태 |
        | **휴면 상태** (sleep) | 디스크가 회전하지 않고 인터페이스도 비활성화된 상태 |
    
    > 요청이 없을 경우, 디스크를 정지시켜 **비활성 상태로 전환**하는 것이 전력 절감 측면에서 효과적이다.
    {: .prompt-info}
    
- 디스크의 상태를 전환할 때는 **부가적인 전력 및 시간**이 소모되므로, **다음 요청까지의 시간 간격이 일정 시간(breakeven time) 이상**일 경우에만 디스크를 **비활성 상태로 전환(= 디스크 회전 정지)**하는 것이 전력 소모를 절감하는 데에 효과적이다.
    
    ![](/assets/img/posts/Computer-Science/Operating-System/2023-10-10-09.jpeg){: .w-75}
    
- **디스크 비활성화 시점의 결정 방법**
    - **시간 기반 기법 (timeout based)**: 일정 시간 동안 디스크가 공회전 상태이면 정지시켰다가, 다시 요청이 왔을 때 디스크를 활성화한다.
    - **예측 기반 기법 (prediction based)**: 과거 요청을 통해 다음 공회전 구간의 길이를 예측한 후 디스크 비활성화 시점을 결정한다.
    - **확률 기반 기법 (stochastic based)**: 디스크의 상태 변경 시간 간격을 구하기 위해 확률 분포를 통해 요청을 모델링하고 통계적 모델을 이용한다.

<br>

### [2] 회전 속도 조절 기법

**디스크의 회전 속도(Rotations Per Minute, RPM)**를 가변적으로 조절하여 디스크의 전력 소모를 줄이는 기법이다.

<br>

### [3] 디스크의 데이터 배치 기법

- 빠른 속도로 증가하고 있는 디스크의 용량에 비해, 디스크의 접근 속도는 기계적 메커니즘으로 인해 큰 발전이 없는 상황이다.
- **FS2 파일 시스템**: 디스크 내에 데이터의 복제본을 많이 만들어 헤드 위치에서 가까운 복제본에 접근하도록 함으로써 빠른 응답 시간과 전력 소모량 절감을 얻는 방식이다.

<br>

### [4] 버퍼 캐싱 및 사전 인출 기법

- 미래에 요청될 데이터를 미리 알거나 어느 정도 예측할 수 있다면, **디스크가 활성 상태**일 때 헤드 위치로부터 가까운 데이터를 **사전 인출(prefetching)**함으로써, 향후 디스크의 비활성화 가능성을 높여 전력 소모를 줄일 수 있다.
- 데드라인을 꼭 지켜야하는 요청이 아니라면, **디스크의 활성 상태**에 따라 **요청을 최대한 지연**시켜 전력 소모를 줄일 수 있다.
- 디스크가 저전력 모드일 때는 **입출력 처리를 최대한 지연**시키고, 디스크가 정상 전력 모드일 때 **사전 인출**을 공격적으로 함으로써 디스크의 상태 변화 횟수를 최소화 할 수도 있다.

<br>

### [5] 쓰기 전략을 통한 저전력 디스크 기법

- **write-back with eager updates:** 대상 디스크가 비활성 상태일 때는 디스크 쓰기를 하지 않고 기다렸다가, 활성 상태로 돌아왔을 때 쓰는 방식
- **write-through with deferred update**: 대상 디스크가 비활성 상태일 때는 블록들을 로그 디스크에 썼다가, 활성 상태로 돌아왔을 때 디스크에 쓰는 방식

<br>

---

## References

- “운영체제와 정보기술의 원리(반효경 저)”, 9장 디스크 관리
  