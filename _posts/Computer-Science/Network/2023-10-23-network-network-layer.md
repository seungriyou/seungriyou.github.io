---
title: "[Network] 3. 네트워크 계층"
date: 2023-10-23 14:50:00 +0900
categories: [Computer Science, Network]
tags: [cs, nw, 네트워크, nw 총정리, network layer, ip, routing, routing table, rip, ospf, bgp, dhcp, nat, icmp, ipsec]     # TAG names should always be lowercase
math: true
mermaid: true
# image: 
#   path: /assets/img/posts/Computer-Science/Operating-System/thumbnail.png
---

> 본문은 "그림으로 공부하는 TCP/IP 구조" 및 각종 자료를 읽고 재구성한 글임을 밝힙니다.

<br>

네트워크 계층은 이더넷이나 무선 LAN에서 만들어진 네트워크를 함께 연결해, <span class="shl">**다른 네트워크에 있는 단말**과의 연결성</span>을 확보하는 계층이다.

- **데이터링크 계층(L2)**: <span class="ulg">같은 네트워크 안</span>에 존재하는 단말들의 연결까지만 담당한다.
- **네트워크 계층(L3)**: 데이터링크 계층에서 만들어진 <span class="ulg">네트워크들을 연결</span>하여 큰 규모의 네트워크를 만든다.

네트워크 계층에서 사용되는 프로토콜은 대부분 **IP(Internet Protocol)**이며, IPv4와 IPv6의 두 가지 버전이 있다.

<br>

---

## 1. IPv4 패킷

IP에 의해 캡슐화되는 패킷이며, **IP 헤더**와 **IP 페이로드**로 구성되어 있다.


![](/assets/img/posts/Computer-Science/Network/2023-10-23-01.png){: .w-75}
_ref: <https://www.gatevidyalay.com/ipv4-ipv4-header-ipv4-header-format/>_

![](/assets/img/posts/Computer-Science/Network/2023-10-23-02.png){: .w-75}
_ref: <https://tribal1012.tistory.com/63>_

1. **<span class="shl">IP 헤더</span> (제어 정보 설정)**
    1. **<span class="shlb">버전</span> (4비트)**: IP의 버전을 나타낸다. (IPv4의 경우, `0100`)
    2. **<span class="shlb">헤더 길이(IHL)</span> (4비트)**: IPv4 헤더의 길이를 4바이트(32비트) 단위로 환산한 값이 들어간다.
        
        > 기본적으로는 IPv4 헤더의 길이가 20바이트이므로, `5`가 들어간다.
        > 
    3. **<span class="shlb">ToS(Type of Service)</span> (8비트, 1바이트)**: IPv4 패킷의 우선도를 나타내는 필드이다.
        - 우선 제어, 대역 제어, 혼잡 제어 등 QoS(Quality of Service)에서 사용한다.
    4. **<span class="shlb">패킷 길이</span> (16비트, 2바이트)**: IPv4 헤더와 IPv4 페이로드를 합친 패킷 전체 길이를 나타낸다.
        - 패킷을 받아들인 단말은 어디까지 IPv4 패킷인지 알 수 있다.
        - **이더넷의 기본 MTU(Maximum Transmission Unit)**까지 데이터가 들어있는 IPv4 패킷의 경우, 패킷 길이 값은 `1500`, 16진수로 `05dc`가 된다.
    5. **<span class="shlb">식별자</span> (16비트, 2바이트)**: IP 프래그멘테이션 관련 정보를 저장한다.
        
        > **IP 프래그멘테이션 (IP Fragmentation)**
        > 
        > - 패킷 교환 방식 통신에서는 데이터를 송신하기 쉽도록 작게 나누어 송신하는데, 이때 IP에서 데이터를 작게 나누는 처리를 IP 프래그멘테이션이라 한다.
        > - L2 페이로드, 즉 IP 패킷에는 MTU까지의 데이터만 저장할 수 있기 때문에 **(1) 트랜스포트 계층에서 MTU 보다 큰 데이터를 받아들이는 상황**이나, **(2) 라우터의 출구 인터페이스의 MTU가 입구보다 더 작은 상황**에서는 MTU에 맞게 데이터를 잘라야 한다.
        >     
        >     > ref: <https://learningnetwork.cisco.com/s/question/0D53i00000Kt4fECAR/ip-fragmentation-and-tcp-sequencing>
        > 
        > - IP 헤더에서 식별자, 플래그, 프래그먼트 오프셋에는 관련 정보가 들어있다.
        {: .prompt-info}
        
        - 패킷을 만들 때 무작위로 할당되는 패킷 ID이다.
        - IPv4 패킷 크기가 MTU 보다 커서 도중에 프래그멘테이션 되면 **프래그먼트 셋은 같은 식별자를 복사**해서 가진다.
        - 패킷을 받은 단말은 이 식별자를 통해 패킷을 재결합한다.
    6. **<span class="shlb">플래그</span> (3비트)**: IP 프래그멘테이션 관련 정보를 저장한다.
        - 1번째 비트는 사용하지 않으며, 2번째 비트는 DF(Don’t Fragment) 비트, 3번째 비트는 MF(More Fragments) 비트이다.
        - **DF 비트**: `0`이면 프래그멘테이션 허가, `1`이면 프래그멘테이션 불허
            - 프래그멘테이션이 발생하면 처리 지연이 발생하고 성능이 저하되므로, 이를 고려하여 프래그멘테이션을 허가하지 않음으로써 상위 계층에서 데이터 크기를 조정한다.
        - **MF 비트**: `1`이면 프래그멘테이션 된 IPv4 패킷이 뒤에 계속됨, `0`이면 계속되지 않음
    7. **<span class="shlb">프래그먼트 오프셋</span> (13비트)**: IP 프래그멘테이션 관련 정보를 저장한다.
        - 해당 패킷이 오리지널 패킷의 앞쪽부터 어느 위치에 있는지를 나타낸다.
        - 프래그멘테이션 된 첫 패킷에는 `0`, 그 뒤 패킷에는 위치를 나타내는 값이 들억나다.
        - 패킷을 받은 단말은 이 값을 보고 IP 패킷의 순서를 올바르게 정렬한다.
    8. **<span class="shlb">TTL(Time To Live)</span> (8비트, 1바이트)**: 패킷의 수명을 나타낸다.
        - IP 패킷의 수명이란, 경유하는 라우터의 수(= 홉, hop)이다.
        - TTL 값은 라우터를 경유할 때마다(= 네트워크를 경유할 때마다) 1씩 감소하며, 값이 `0`이 되면 패킷이 파기된다.
        - 패킷을 폐기한 라우터는 `Time-to-live exceed`라는 ICMPv4 패킷을 반환하고, 패킷 파기 사실을 송신지 단말에 전달한다.
    9. **<span class="shlb">프로토콜 번호</span> (8비트, 1바이트)**: IPv4 페이로드가 어떤 프로토콜로 구성되어 있는지 나타낸다.
        
        > ex) `1` - ICMP, `2` - IGMP, `6` - TCP, `17` - UDP, `89` - OSPF 등
        > 
    10. **<span class="shlb">헤더 체크섬</span> (16비트, 2바이트)**: IPv4 헤더의 정합성을 체크하기 위해 사용되는 필드이다. (1의 보수 연산)
    11. **<span class="shlb">송신지/수신지 IPv4 주소</span> (32비트, 4바이트)**
    12. **<span class="shlb">옵션</span> (가변 길이)**: 실무에서는 잘 사용되지 않는다.
    13. **<span class="shlb">패딩</span> (가변 길이)**: IPv4 헤더의 비트 수를 4바이트(32비트) 단위로 정렬하기 위해 사용한다.
        
        > 4바이트의 정수 배가 되지 않으면 패딩 `0`을 추가해 4바이트의 정수 배가 되도록 한다.
        > 
2. **<span class="shl">IP 페이로드</span> (데이터 자체)**

<br>

---

## 2. IPv4 주소

### 2-1. 개요

IPv4 네트워크에 연결되어 있는 단말을 나타내는 **4바이트(32비트)**의 식별 ID로, IPv4 네트워크에서의 주소이다. 

- IP 네트워크에서 통신하는 단말(PC, 서버의 NIC, 라우터, 방화벽, 관리 가능한 L2 스위치 등)은 모두 IP 주소를 가진다.
- 단말 하나당 반드시 하나의 IP만 가질 수 있는 것은 아니며, 기기 종류나 용도에 따라 여러 IP 주소를 가질 수도 있다.

IPv4 주소는 **8비트(1바이트)씩 점(`.`)으로 구분**해서 **10진수**로 표기한다.

> **MAC 주소와 IP 주소가 모두 필요한 이유**
> 
> <span class="ulr">**MAC 주소**</span>는 NIC에 할당된 물리적인 주소로, **‘다음에 어떤 기기에 프레임을 전달하는가’**를 지정하는 주소이다. 반면, <span class="ulr">**IP 주소**</span>는 OS에 할당된 논리적인 주소로, **‘최종적으로 어디에 패킷을 전달하는지’**를 지정하는 주소로 사용한다. 그리고 이 두 주소를 연결하는 것이 <span class="ulg">**ARP**</span>이다.
> 
> 이더넷 네트워크에서 통신하기 위해서는 MAC 주소가, IP 네트워크에서 통신하기 위해서는 IP 주소가 필요하기 때문에, 데이터링크 계층과 네트워크 계층에서 각 프로토콜을 주로 사용하는 현대 네트워크에서는 양쪽 주소가 반드시 필요하다.
{: .prompt-tip}

<br>

### 2-2. 서브넷 마스크

IPv4 주소는 **서브넷 마스크(subnet mask)**라는 **4바이트(32비트)** 값과 함께 사용한다.

IPv4 주소는 **네트워크 부분(network part)**과 **호스트 부분(host part)**로 구성되어 있으며, 서브넷 마스크는 이 두 부분을 구분하는 역할을 한다.

| 구분          | 의미                        | 서브넷 마스크의 비트 값 |
| ------------- | --------------------------- | ----------------------- |
| 네트워크 부분 | 어떤 IPv4 네트워크에 있는가 | `1` 비트                  |
| 호스트 부분   | 어떤 단말인가               | `0` 비트                  |

서브넷 마스크는 두 가지 방법으로 표기할 수 있다.

1. **10진수 표기**: IPv4 주소처럼 32비트를 8비트씩 4개 그룹으로 나누어 10진수로 변환하고 점으로 구분하여 표기한다.
2. **CIDR 표기**: IPv4 주소 뒤에 `/`와 서브넷 마스크의 `1`의 비트 수를 표기한다.
    
    > ex) `192.168.100.1/24`에서 네트워크 부분은 `192.168.100`, 호스트 부분은 `1`이다.
    > 

<br>

### 2-3. IPv4 주소의 분류

#### [1] 사용 용도에 따른 분류
- 클래스 A ~ 클래스 E까지 그룹이 존재하며, 일반적으로 유니캐스트용인 클래스 A ~ C를 사용한다.

    > 네트워크 규모는 A → B → C 순서로 작아진다.

- 주소 클래스 분류는 32비트의 IPv4 주소 중 **앞의 1~4비트로 수행**한다.

- **IPv4 주소 할당 방식**
    1. <span class="ulr">**클래스풀 어드레싱**</span>: 주소 클래스에 기반해 IPv4 주소를 할당하는 방식
       - 8비트 단위로 서브넷 마스크를 준비하는 방식이다. 즉, 네트워크 부분과 호스트 부분은 8비트, 16비트, 24비트 등이 된다.
       - 알기 쉽고 관리하기 쉽다는 장점이 있으나, 낭비가 심하다.
    2. <span class="ulr">**클래스리스 어드레싱**</span>: 8비트 단위의 주소 클래스에 관계 없이 IPv4 주소를 할당하는 방식 (= 서브네팅, CIDR)
       - 서브넷 마스크를 8비트 단위가 아니라 1비트 단위로 자유롭게 적용함으로써, 유한한 IP 주소를 효율적으로 사용한다.
       - 네트워크 부분과 호스트 부분뿐만 아니라 **서브넷 부분**이라는 새로운 개념을 도입한다. 원래는 호스트 부분으로서 사용되는 부분이나, **필요한 IP 주소의 수** 또는 **필요한 네트워크의 수**에 맞추어 서브넷 부분에 할당할 수 있다.
       - 예를 들어 `192.168.1.0/28`은, 네트워크 부분/호스트 부분이 24비트/8비트인 클래스 C에서 **네트워크를 16개로 분할**하기 위해 **4비트를 서브넷 부분으로 할당**한 것이다. 따라서 4비트를 네트워크 부분으로 추가로 사용함으로써 **16개(= $2^4$)의 <span class="shlb">서브넷 네트워크</span>**를 만들 수 있고, 각 서브넷 네트워크에는 **최대 14개(= $2^4-2$)의 <span class="shlb">IP 주소</span>**를 할당할 수 있다.
           
           > 네트워크 주소와 브로드캐스트 주소는 단말에 할당할 수 없기 때문에 IP 주소의 개수를 셀 때 2를 뺀다.
           {: .prompt-tip}
                
#### [2] 사용 장소에 따른 분류
1. **<span class="ulr">글로벌 IPv4 주소</span> (퍼블릭 IP 주소, 공인 IP 주소)**: 인터넷에서의 IP 주소이다. 현재는 남은 숫자가 부족해서 최근에는 할당에 제한이 있다.
2. **<span class="ulr">프라이빗 IPv4 주소</span> (로컬 IP 주소, 사설 IP 주소)**: 기업이나 가정 등 한정된 조직 안에서 자유롭게 할당할 수 있는 IPv4 주소이다.
   - 주소 클래스별로 정의되어 있으며, 가정에서 브로드밴드 라우터를 사용할 때는 주로 클래스 C로 정의된 `192.168.x.x` 주소가 설정되어 있다.
   - 조직 내에서만 유효한 IPv4 주소이므로, **인터넷에 접속할 때에는 프라이빗 IPv4 주소를 글로벌 IPv4 주소로 변환**해야 한다. 이러한 기능을 **<span class="shl">NAT(Network Address Translation)</span>**이라 한다. 가정에서는 브로드밴드 라우터가 **송신지 IPv4 주소**를 프라이빗 IPv4 주소에서 글로벌 IPv4 주소로 변환한다.

#### [3] 예외 주소

> 클래스 A ~ C 중에서도 특별한 용도로 사용되기 때문에 단말에는 설정할 수 없는 주소가 있다. 그 중에서 대표적인 것에는 네트워크 주소, 브로드캐스트 주소, 루프백 주소가 있다.

1. **<span class="ulr">네트워크 주소</span>**
  - **호스트 부분의 비트가 모두 `0`**인 주소로, **네트워크 자체**를 나타낸다.
  - 서브넷 마스크를 모두 `0`으로 설정함으로써 네트워크 주소를 최대한으로 설정한 주소인 **`0.0.0.0/0`은 기본 경로 주소**라하며, 이는 **“모든 네트워크”**를 의미한다.
2. **<span class="ulr">브로드캐스트 주소</span>**
  - **호스트 부분의 비트가 모두 `1`**인 주소로, 같은 네트워크에 존재하는 **모든 단말**을 나타낸다.
  - 서브넷 마스크를 모두 `1`로 설정함으로써 브로드캐스트 주소를 최대한으로 설정한 주소인 **`255.255.255.255/32`는 리미티드 브로드캐스트 주소**라 하며, **브로드캐스트 주소와 마찬가지**로 같은 네트워크에 있는 모든 단말에 패킷이 송신된다.
      
      > 자신의 IPv4 주소나 네트워크 주소를 알 수 없을 때, DHCPv4로 주소를 얻을 때 등에 사용한다.
      > 
3. **<span class="ulr">루프백 주소</span>**
  - **자기자신**을 나타내는 주소로, 1옥텟이 `127`인 IPv4 주소이다.
  - 통상 `127.0.0.1/8`을 사용한다.

<br>

---

## 3. IPv6

### 3-1. IPv4와의 차이점

1. <span class="shlp">**패킷 헤더 길이 고정**</span>
    
    IPv4는 가변 길이 옵션 필드가 있기 때문에 헤더의 길이가 **20바이트**에서 달라진다. 반면, IPv6은 IPv4에서 거의 사용 되지 않던 옵션 필드를 ‘확장 헤더’라는 다른 헤더로 분리하여 IP 페이로드 앞에 배치함으로써, **헤더 길이를 40바이트로 고정**한다.
    
    따라서 패킷 헤더의 길이를 조사할 필요가 없으며, 그만큼 **네트워크 기기의 처리 부하**가 줄고 **성능이 향상**된다.
    
2. <span class="shlp">**패킷 필드 수 감소**</span>
    
    성능 향상에 도움이 되지 않는 필드를 줄여 필드를 일일이 조사할 필요가 없도록 하였으며, 네트워크 기기의 처리 부하를 줄이고 성능을 향상시켰다.
    
3. <span class="shlp">**주소 길이 증가**</span>
    
    **32비트(4바이트)였던 IPv4 주소**보다 4배 긴 **128비트(16바이트)의 주소**를 사용함으로써 IPv4의 주소 부족 문제를 해결한다.
    

<br>

### 3-2. IPv6 패킷 헤더

![](/assets/img/posts/Computer-Science/Network/2023-10-23-03.png){: .w-75}
_ref: <https://en.m.wikipedia.org/wiki/File:IPv6_header_rv1.png>_

![](/assets/img/posts/Computer-Science/Network/2023-10-23-04.png){: .w-75}
_ref: <https://physicallaw.tistory.com/100>_

<br>

---

## 4. IP 라우팅

네트워크 계층에서 동작하는 네트워크 기기는 **라우터**와 **L3 스위치**가 있으며, 이는 다른 네트워크를 연결하고 IP 패킷을 전송하는 역할을 한다.

<br>

### 4-1. 라우팅

라우터나 L3 스위치는 수신지 IP 주소, 수신지 네트워크 정보, 네트워크 홉 정보를 관리함으로써 <span class="shl">**IP 패킷의 전송 대상지를 바꾸며**</span>, 이러한 기능을 <span class="shl">**라우팅(routing)**</span>이라 한다.

> **네트워크 홉** 정보란, IP 패킷을 전송할 근접 기기의 IP 주소를 나타낸다.
{: .prompt-info}

또한, 수신지 네트워크와 네트워크 홉을 관리하는 표(테이블)를 <span class="shl">**라우팅 테이블(routing table)**</span>이라 한다.

<br>

모든 기기가 근접 기기의 MAC 주소를 학습한 상태일 때, 2대의 라우터를 거쳐 PC1(`192.168.1.1`)과 PC2(`192.168.2.1`)가 IP 패킷을 교환하는 상황에서, **라우터가 IP 패킷을 라우팅하는 과정**은 다음과 같다.

![](/assets/img/posts/Computer-Science/Network/2023-10-23-05.jpeg){: .w-75}

1. **PC1**은 <span class="shl">**IP 헤더를 캡슐화**</span>한 뒤, 자신의 <span class="blue">**라우팅 테이블**</span>에서 **수신지 IP 주소**(= PC2의 IP 주소)와 일치하는 항목을 검색한다. 이때, PC2의 IP 주소는 `192.168.1.0/24`와 일치하지 않으므로, 모든 네트워크를 나타내는 **기본 경로 주소 `0.0.0.0/0`**과 일치하게 된다.
    
    기본 경로 주소의 **넥스트 홉 `192.168.1.254`의 MAC 주소**를 <span class="blue">**ARP 테이블**</span>에서 검색한다. 이를 통해 수신지 MAC 주소(= 넥스트 홉의 MAC 주소)를 얻고, <span class="shl">**이더넷으로 캡슐화**</span>한 뒤 케이블로 보낸다.
    
    > **기본 경로의 넥스트 홉**을 <span class="ulr">**디폴트 게이트웨이**</span>라 한다. 단말은 인터넷상에 존재하는 불특정 다수의 웹사이트에 접속할 때, 우선 디폴트 게이트웨이에 IP 패킷을 전송한 뒤, 이후의 과정은 디폴트 게이트웨이 기기의 라우팅에 일임한다.
    > 
    > 
    > 가정의 LAN 환경에서의 디폴트 게이트웨이는 브로드밴드 라우터의 IP 주소이며, 브로드밴트 라우터의 디폴트 게이트웨이는 **계약된 ISP의 IP 주소**로 설정되어 있다. 따라서 IP 패킷은 이러한 과정을 통해 전송되며, ISP로부터 수많은 라우터를 거쳐 인터넷으로 나간다.
    {: .prompt-info}
    
    ![](/assets/img/posts/Computer-Science/Network/2023-10-23-06.jpeg){: .w-75}
    
2. **R1**은 PC1로부터 IP 패킷을 받은 후, <span class="shl">**IP 헤더**</span>의 수신지 IP 주소(= PC2의 IP 주소)를 보고 <span class="blue">**라우팅 테이블**</span>을 검색한다. 라우팅 테이블의 `192.168.2.0/24`와 일치하므로, 그것과 일치하는 넥스트 홉인 `192.168.12.2`의 MAC 주소를 <span class="blue">**ARP 테이블**</span>에서 검색한다. 이를 수신지 MAC 주소로 하여 <span class="shl">**이더넷으로 캡슐화**</span>한 뒤 케이블로 보낸다.
    
    ![](/assets/img/posts/Computer-Science/Network/2023-10-23-07.jpeg){: .w-75}
    
3. **R2**는 R1으로부터 IP 패킷을 받은 후, <span class="shl">**IP 헤더**</span>의 수신지 IP 주소(= PC2의 IP 주소)를 보고 <span class="blue">**라우팅 테이블**</span>을 검색한다. 라우팅 테이블의 `192.168.2.0/24`와 일치하는데, 라우팅 테이블에서 `직접 접속`으로 되어있으므로 **수신지 IP 주소의 MAC 주소**를 <span class="blue">**ARP 테이블**</span>에서 검색한다. 이를 수신지 MAC 주소로 하여 <span class="shl">**이더넷으로 캡슐화**</span>한 뒤 케이블로 보낸다.
    
    ![](/assets/img/posts/Computer-Science/Network/2023-10-23-08.jpeg){: .w-75}
    
4. R2로부터 IP 패킷을 받은 **PC2**는 <span class="shl">**데이터링크 계층**</span>에서 **수신지 MAC 주소**, <span class="shl">**네트워크 계층**</span>에서 **수신지 IP 주소**를 보고 패킷을 받아들인다. 그리고 상위 계층으로 처리를 위임한다.
    
    ![](/assets/img/posts/Computer-Science/Network/2023-10-23-09.jpeg){: .w-50}
    

<br>

### 4-2. 라우팅 테이블을 만드는 방법

그렇다면 라우팅 테이블은 어떻게 만들어야 할까? **라우팅 테이블을 만드는 방법**은 크게 두 가지로 나뉜다.

- **정적 라우팅(static routing)**: 수동으로 라우팅 테이블을 만든다.
- **동적 라우팅(dynamic routing)**: 자동으로 라우팅 테이블을 만든다.

이때, **정적 라우팅**은 모든 라우터에 대해 수신지 네트워크와 넥스트 홉을 하나하나 설정해주어야 하기 때문에 대규모의 네트워크 환경에는 적합하지 않다.

반면, <span class="shl">**동적 라우팅**</span>은 <span class="ulr">근접한 라우터끼리 자신이 가진 **경로 정보를 교환해 자동으로 라우팅 테이블을 만드는 방법**</span>이다. **동적 라우팅의 장점**으로는 다음과 같은 것들이 있다.

1. 라우터에 경로를 하나하나 설정할 필요가 없으므로 규모가 큰 네트워크 환경이나 구성이 변하기 쉬운 환경에서 사용하기 편리하다.
2. 수신지까지의 경로 중 어딘가에 장애가 발생해도 자동으로 우회 경로를 탐색하므로 장애에 대한 내성이 향상된다.

또한, <span class="ulr">경로 정보를 교환하기 위한 프로토콜</span>을 <span class="shl">**라우팅 프로토콜**</span>이라 하며, 네트워크상의 라우터가 모든 경로를 인식한 상태를 **수렴 상태**라 한다.

<br>

---

## 5. 라우팅 프로토콜: 라우팅 테이블을 어떻게 만드는가?

제어 범위에 따라 **IGP(Interior Gateway Protocol)**와 **EGP(Exterior Gateway Protocol)**로 나눌 수 있다.

이 두 가지를 나누는 개념은 **AS(Autonomous System)**이며, 이는 하나의 정책에 따라 관리되는 네트워크 집합이다. <span class="ulg">AS 내부를 제어</span>하는 라우팅 프로토콜이 **IGP**, <span class="ulg">AS 사이를 제어</span>하는 라우팅 프로토콜이 **EGP**이다.

<br>

### 5-1. IGP(Interior Gateway Protocol)

IGP에는 RIP, OSPF, EIGRP 등이 있으며, 다음의 두 가지가 핵심이다.

- <span class="shl">**라우팅 알고리즘**</span>: 라우팅 테이블을 만드는 방법에 대한 규칙
    - **<span class="ulr">디스턴스 벡터 타입</span>(distance vector)**: 거리와 방향에 기반해 경로를 계산한다.
        - 거리는 수신지에 이를 때까지 경유하는 라우터의 수(= 홉 수)이며, 방향이란 출력 인터페이스를 나타낸다.
        - 수신지까지 얼마나 많은 라우터를 경유하는지가 최적 경로의 판단 기준이 된다.
        - 서로의 라우팅 테이블을 교환함으로써 라우팅 테이블을 만든다.
    - **<span class="ulr">링크 스테이트 타입</span>(link state)**: 링크 상태에 기반해 최적 경로를 계산한다.
        - 각 라우터가 자신의 링크 상태, 대역폭, IP 주소 등 다양한 정보를 교환해 데이터베이스를 만들고, 그 정보를 기반으로 라우팅 테이블을 만든다.
- <span class="shl">**메트릭**</span>: 수신지 네트워크까지의 논리적인 거리
    
    > 라우팅 프로토콜에 따라 다르다!

<br>

주요 IGP 프로토콜을 비교하면 다음과 같다.

| 라우팅 프로토콜 | RIP                          | OSPF                    |
| --------------- | ---------------------------- | ----------------------- |
| 정식 명칭       | Routing Information Protocol | Open Shortest Path Fast |
| 라우팅 알고리즘 | 디스턴스 벡터 타입           | 링크 스테이트 타입      |
| 메트릭          | 홉 수 (경유하는 네트워크 수) | 비용                    |
| 업데이트 간격   | 정기적                       | 구성이 변경되었을 때    |
| 적용 규모       | 소규모                       | 중규모~대규모           |

#### [1] <span class="ulr">RIP</span>(Routing Information Protocol)
- **라우팅 테이블 자체를 정기적으로 교환**함으로써 라우팅 테이블을 만든다.
- 대규모의 네트워크 환경에는 어울리지 않는다.
  - 라우팅 테이블이 커질수록 교환할 때 불필요한 네트워크 대역을 소비한다.
  - 수렴하는 데에 시간이 걸린다.
- 메트릭으로 홉 수, 즉 경유하는 네트워크 수를 사용하는데, 이는 간단하지만 대역폭이 작은 곳이 있더라도 홉 수가 적은 경로를 최적 경로로 판단해버리는 문제가 있다.
- 현재는 거의 사용하지 않는다.

#### [2] <span class="ulr">OSPF</span>(Open Shortest Path Fast)
    
> ref: <https://itwiki.kr/w/OSPF>

- 각 라우터가 다양한 정보(링크 상태, 대역폭, IP 주소, 서브넷 마스크 등)를 교환하면서 **링크 스테이트 데이터베이스(LSDB)**를 만든다. 각 라우터는 자신의 LSDB를 기반으로 **최적의 경로 정보를 계산**하고 **라우팅 테이블**을 만든다.

    > 이때, 최단 경로를 선택하기 위해 다익스트라의 SPF(Shortest Path First) 알고리즘을 사용한다.
 
- 평소에는 작은 패킷(`Hello` 패킷)을 송신해 상대가 정상 동작하는지 확인하기 때문에 필요 이상으로 대역을 소비하지 않으며, **변경이 있을 때에만 라우팅 테이블을 업데이트** 한다.
- LSDB가 너무 커지지 않도록 네트워크를 에어리어(area)로 나누고, **같은 에어리어 내 라우터끼리**만 LSDB를 공유하도록 한다.
- 메트릭으로 비용을 사용하며, 기본으로 `100 / 대역폭(Mbps)`의 계산 결과를 정숫값으로 하여 라우터를 넘을 때마다 출력 인터페이스에서 계산되어 더해진다. 이를 ECMP(Equal Cost Multi Path)라 한다.
    
    > 대역이 작으면 비용이 커진다.

<br>

### 5-2. EGP(Exterior Gateway Protocol): <span class="ulr">BGP</span>(Border Gateway Protocol)

AS와 AS를 연결하는 EGP로는 일반적으로 **BGP(Border Gateway Protocol)**를 사용한다. 인터넷은 BGP로 지구 전체의 AS를 그물 형태로 연결한 것이라 할 수 있다.

> 각 AS 안에서는 IGP가 동작한다.

<br>

BGP의 핵심에는 **AS 번호, 라우팅 알고리즘, 최선 경로 선택 알고리즘**이 있다.

1. **AS 번호**
    - 인터넷은 전 세계에 존재하는 AS를 BGP가 동작하는 라우터로 연결함으로써 성립하며, 이때 AS를 식별하는 번호를 AS 번호라고 한다.
2. **라우팅 알고리즘**
    - BGP는 **경로 벡터 타입**의 라우팅 알고리즘을 사용하며, 경로와 방향에 기반해 경로를 계산한다. 수신지까지 **얼마만큼의 AS를 경유하는지**가 최선 경로를 판단하는 기준 중 하나가 된다.
        - **경로** = 수신지까지 경유하는 AS의 번호들
        - **방향** = BGP 피어(경로 정보를 교환하는 상대)
    - BGP 라우터는 **BGP 피어와 1:1 TCP 커넥션**을 만들고, 그 과정에서 경로 정보를 교환한다. 이 정보를 통해 **BGP 테이블**을 만들고, 최선 경로 선택 알고리즘에 기반해 **최선 경로를 선택**한다. 그리고 **최선 경로만 라우팅 테이블에 추가**하는 동시에 **BGP 피어에게 전파**한다.
    - OSPF와 마찬가지로 **변경이 있을 때만** 라우팅 테이블을 업데이트 한다.
    - 보통 때에는 `KEEPALIVE` 메시지로 상대가 정상 동작하는지 판단하며, 업데이트 시에는 `UPDATE` 메시지를 사용한다.
3. **최선 경로 선택 알고리즘**
    - 어떤 경로를 최선 경로로 판단하는가에 관한 규칙을 나타낸다.
    - BGP 경로 제어에는 **어트리뷰트**를 사용하며, `UPDATE` 메시지 안에 `NEXT_HOP`이나 `LOCAL_PREF` 등 다양한 어트리뷰트를 가지고 있어 이를 포함하여 BGP 테이블에 기록한다.
    - 정해진 순서에 따라 우열을 가리며, 선택한 최선 경로를 **라우팅 테이블에 추가**하고 동시에 **BGP 피어에게 전파**한다.

<br>

---

## 6. 라우팅 테이블 규칙: 라우팅 테이블을 어떻게 사용하는가?

### 6-1. 롱기스트 매치 (Longest Match)

라우터는 IP 패킷을 받으면 수신지 IP 주소를 라우팅 테이블에 등록된 경로와 대조한다. 이때 수신지 IP 주소의 조건에 맞는 경로가 여러 개 있을 때, **서브넷 마스크가 가장 긴 경로를 사용**하는 규칙이다.

예를 들어 수신지 IP 주소가 `192.168.1.1`이고, 라우팅 테이블의 수신지 네트워크로 `192.168.0.0/16`, `192.168.1.0/24`, `192.168.1.0/26`이 있다면, 이들은 모두 조건에 일치하기 때문에 이중에서 서브넷 마스크가 가장 긴 `192.168.1.0/26`을 선택한다.

<br>

### 6-2. 경로 집약 (Route Aggregation)

**여러 경로를 모으는 것**으로, 라우터에서 IP 패킷을 받을 때 라우팅 테이블에 등록되어 있는 경로를 하나하나 체크할 때 부하가 늘어나는 단점을 보완하기 위한 것이다. **넥스트 홉이 같은 여러 경로를 모음**으로써, 경로의 수와 라우터 부하를 줄인다.

이를 위해 넥스트 홉이 같은 경로의 **네트워크 주소를 비트로 변환**하여, **공통된 비트까지 서브넷 마스크를 이동**시킨다. 그리고 경로 집약을 극한까지 실행하여 모든 경로를 하나로 집약한 것이 바로 **기본 경로 `0.0.0.0/0`**이다. 라우터가 IP 패킷을 받았을 때 수신지 IP 주소에 합치하는 경로가 없다면, **기본 경로의 넥스트 홉**인 **디폴트 게이트웨이**로 패킷을 전송한다.

<br>

### 6-3. AD 값 (Administrative Distance)

**라우팅 프로토콜별로 결정된 우선도**로, 값이 작을수록 우선도가 높다.

여러 라우팅 프로토콜(동적 라우팅) 혹은 정적 라우팅으로 학습한 결과가 완전히 동일한 경우, 롱기스트 매치를 적용할 수 없다. 이럴 때, 라우팅 프로토콜의 AD 값을 비교하여 **AD 값이 작은 경로만 라우팅 테이블에 등록**하고, 그 경로를 우선 사용한다.

AD 값은 네트워크 기기별로 결정되어 있다.

<br>

---

## 7. IP 주소 할당 방법

IP 주소를 어떻게 단말(의 NIC)에 할당할까? 이 방법에는 크게 두 가지가 있다.

- **정적 할당(static allocation)**: 각 단말별로 수동으로 IP 주소를 설정하는 방법
    
    > 사람이 사용 가능한 IP 주소를 할당해준다.
    > 
- **동적 할당(dynamic allocation)**: 단말에 대해 자동으로 IP 주소를 설정하는 방법
    
    > (ex) DHCP 서버로부터 사용 가능한 IP 주소를 할당받는다.
    > 

**정적 할당**의 경우, 단말과 IP 주소가 유일하게 연결되므로 IP 주소를 관리하기 쉽고 이상 현상을 파악하기 쉽지만, 단말의 수가 많아질수록 관리가 복잡해지기 때문에 소규모 환경이나 서버/네트워크 기기에 사용한다.

대규모의 LAN 환경에서는 보통 **동적 할당**을 사용하여 일괄적으로 IP 주소를 관리하며, 대표적으로 <span class="shl">**DHCP(Dynamic Host Configuration Protocol)**</span>를 사용한다. 동적 할당은 IPv4와 IPv6에서 그 방법이 다르며, 여기에서는 DHCPv4만 알아보자.

<br>

### 7-1. DHCPv4 (Dynamic Host Configuration Protocol)

IPv4 주소 동적 할당에 사용하는 프로토콜이다. DHCPv4 서버에서 단말에 대해 <span class="ulr">**네트워크에 연결하기 위해 필요한 설정(IPv4 주소, 디폴트 게이트웨이, DNS 서버의 IP 주소 등)을 배포**</span>한다. 또한, **브로드캐스트와 유니캐스트** 양쪽을 사용하면서 **UDP**로 교환한다.

> DHCPv4 서버에 요청을 보내는 DHCP 클라이언트는 OS라고 생각하면 된다.

1. `DHCP Discover`: DHCPv4 클라이언트는 브로드캐스트로 IP 주소 할당 요청을 보낸다.
2. `DHCP Offer`: DHCPv4 서버는 유니캐스트로 설정을 응답한다.
3. `DHCP Request`: 클라이언트는 브로드캐스트로 요청한다.
4. `DHCP ACK`: 서버는 클라이언트에게 유니캐스트로 해당 정보를 사용하라고 허가한다.
5. 클라이언트는 받은 **설정 정보를 적용**하고, 서버는 **DHCP 데이터베이스에 배포**한 IPv4 주소를 등록한다.
    
    > **클라이언트가 설정하는 정보**: IPv4 주소, 디폴트 게이트웨이, DNS 서버 등
    {: .prompt-info}

<br>

---

## 8. NAT(Network Address Translation)

IP 주소를 변환하는 기술로, 다음과 같은 이유로 사용한다.

1. <span class="ulr">**부족한 글로벌 IP 주소를 절약**</span>할 수 있다.
2. 같은 네트워크 주소를 가진 시스템 사이에서 통신할 수 있다.

NAT는 변환 전후의 IP 주소나 포트 번호를 **NAT 테이블**이라는 테이블로 묶어서 관리한다.

<br>

### 8-1. 정적 NAT (Static NAT)

**내부(LAN)와 외부(인터넷)의 IP 주소를 1:1로** 묶어서 변환하며, 좁은 의미의 NAT이다.

미리 NAT 테이블에 내부 IP 주소와 외부 IP 주소를 1:1로 묶는 NAT 엔트리를 가지고 있다.

| 액세스 방향 | NAT으로 변환하는 IP 주소 |
| ----------- | ------------------------ |
| 내부 → 외부 | 송신지 IP 주소를 변환    |
| 내부 ← 외부 | 수신지 IP 주소를 변환    |

<br>

### 8-2. NAT 트래버설 (NAT Traversal): 포트 포워딩 (Port Forwarding)

> **NAT 아래의 단말은 프라이빗 IP 주소만** 가지고 있으므로 인터넷을 경유해 직접 통신할 수는 없다. 따라서 NAT에는 NAT 기기를 뛰어넘어 **단말끼리 직접 통신할 수 있도록 지원하는 기술**로 **NAT 트래버설**이 있다. 그리고 NAT 트래버설에는 대표적으로 **포트 포워딩**이 있다.
> 

**특정 IP 주소/포트 번호에 대한 통신**을 **미리 설정해 둔 내부 단말로 전송**하는 기능이다. 내부(LAN)에 있는 서버를 외부(인터넷)에 공개할 때 사용한다.

<br>

---

## 9. ICMP (Internet Control Message Protocol)

네트워크 계층의 프로토콜 중 하나로, 이름 그대로 **인터넷을 제어하는 메시지를 교환**하는 프로토콜이다.

다음과 같은 동작을 통해 IP를 돕는 역할을 한다. (엄밀히 말해, IPv4와 ICMPv4는 반드시 함께 구현되어야 한다.)

- **IP 레벨의 통신 상태**를 확인한다.
- 다양한 **에러**를 알린다.

`ping`은 ICMP 패킷을 송신할 때 사용하는 네트워크 진단 프로그램(명령어)이며, IPv4와 IPv6에 따라 ICMPv4와 ICMPv6으로 나뉜다. 여기에서는 ICMPv4만 다룬다.

<br>

### 9-1. ICMPv4 패킷

- ICMPv4 패킷은 **사실 IPv4 패킷**이다.
    1. IP 헤더의 **프로토콜 번호**로 `1`을 입력한다.
    2. IP 페이로드 부분에 ICMP 메시지를 직접 입력한다.
    3. 메시지의 처음 부분에 **타입, 코드, 체크섬**을 넣는다.
        
        > 타입과 코드를 조합하여 IP 레벨에서 어떤 일이 일어나는지 간략하게 파악할 수 있다.
        
- ICMP는 통신 결과나 간단한 에러 내용을 반환한다.

<br>

### 9-2. 대표적인 동작

1. <span class="shl">**에코 요청/응답**</span>
    - **IP 레벨의 통신 상태**를 확인할 때 사용되는 ICMPv4 패킷이다. (`ping` 명령어)
    - `ping`으로 트러블슈팅을 시작한다.
        - 에코 응답이 돌아오면 네트워크 계층 레벨의 소통이 확인된 것이므로, 트랜스포트 계층 등 **상위 계층을 향해** 소통을 확인한다.
        - 에코 응답이 돌아오지 않으면 네트워크 계층 레벨부터 **하위 계층 방향으로** 소통을 확인한다.
2. <span class="shl">**Destination Unreachable**</span>
    - IPv4 패킷을 **수신지 IPv4 주소의 단말까지 라우팅하지 못했을 때**, 에러를 알리는 ICMPv4 패킷이다.
    - IPv4 패킷을 **라우팅하지 못한 라우터**는 다음과 같은 동작을 수행한다.
        - IP 패킷을 파기한다.
        - 송신지 IPv4 주소로 ICMPv4 패킷을 반환한다.
3. <span class="shl">**Time-to-live Exceeded**</span>
    - **IPv4 패킷의 TTL이 `0`이 되어 파기**했을 때, 그것을 송신지 단말에게 알리는 ICMPv4 패킷이다.
    - **[역할 1] 라우팅 루프 방지**
        - 라우팅 설정 실수에 의해 IP 패킷이 여러 라우터를 통해 빙글빙글 도는 현상을 라우팅 루프라 한다.
        - 루프를 돌다가 TTL이 `1`인 패킷을 받으면 파기하면서 ICMP에서 파기했음을 알린다.
    - **[역할 2] 통신 경로 확인**
        - `traceroute` 프로그램에서는 TTL을 `1`에서 하나씩 증가시킨 IPv4 패킷을 보내서 어떤 경로를 통해 수신지 IP 주소까지 도달하는지 확인한다.

<br>

---

## 10. IPsec

네트워크 계층에서 IP 패킷을 캡슐화, 인증, 암호화하고 인터넷 상에 가상의 전용선(터널)을 만드는 가상화 기술이다.

<br>

---

## References

- "그림으로 공부하는 TCP/IP 구조(미야타 히로시 저)", Ch4. 네트워크 계층
- <https://www.gatevidyalay.com/ipv4-ipv4-header-ipv4-header-format/>
- <https://tribal1012.tistory.com/63>
- <https://learningnetwork.cisco.com/s/question/0D53i00000Kt4fECAR/ip-fragmentation-and-tcp-sequencing>
- <https://en.m.wikipedia.org/wiki/File:IPv6_header_rv1.png>
- <https://physicallaw.tistory.com/100>
- <https://itwiki.kr/w/OSPF>
