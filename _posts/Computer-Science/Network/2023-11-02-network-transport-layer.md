---
title: "[Network] 4. 트랜스포트 계층"
date: 2023-11-02 14:50:00 +0900
categories: [Computer Science, Network]
tags: [cs, nw, 네트워크, nw 총정리, transport layer, udp, tcp, 3-way handshake, 4-way handshake, flow control, error control, congestion control, firewall]     # TAG names should always be lowercase
math: true
mermaid: true
# image: 
#   path: /assets/img/posts/Computer-Science/Operating-System/thumbnail.png
---

> 본문은 "그림으로 공부하는 TCP/IP 구조" 및 각종 자료를 읽고 재구성한 글임을 밝힙니다.

<br>

트랜스포트 계층은 다음의 동작을 통해 <span class="shl">**네트워크와 애플리케이션을 연결**</span>하는 역할을 한다.

1. **포트 번호**를 이용하여 **애플리케이션 식별**
2. 요구에 맞는 **전송 제어**
    - 패킷 송수신량 제어
    - 손실된 패킷 재전송 등

트랜스포트 계층에서 사용되는 프로토콜은 UDP 또는 TCP 중 하나이다. **실시간성이 요구될 때는 UDP**, **신뢰성이 요구될 때는 TCP**를 사용한다.

| 항목                    | UDP                   | TCP                |
| ----------------------- | --------------------- | ------------------ |
| **패킷 이름**               | 데이터그램 (datagram) | 세그먼트 (segment) |
| **IP 헤더의 프로토콜 번호** | `17`                    | `6`                  |
| **신뢰성**                  | ⬇️                     | ⬆️                  |
| **실시간성**                | ⬆️                     | ⬇️                  |
| **타입**                    | 커넥션리스 타입       | 커넥션 타입        |

<br>

---

## 1. UDP (User Datagram Protocol)

- 음성 통신, 이름 결정, DHCP, 시각 동기화 등 <span class="ulr">**실시간성**</span>을 필요로하는 애플리케이션에서 사용한다.
- <span class="ulr">**커넥션리스 타입**</span>이므로, 갑자기 **UDP 커넥션**이라는 통신로를 만들고 애플리케이션 데이터를 송신한다.
- 실시간성을 위해 **포맷을 간단**하게 하거나 **확인 응답을 생략**한다.
- 클라이언트는 **UDP 데이터그램**을 만들고 계속 보내기만 하며, 서버는 UDP 헤더에 포함된 **UDP 데이터그램 길이**와 **체크섬**을 이용해 데이터가 손상되었는지 여부를 체크하고 받아들인다.

<br>

### 1-1. UDP 데이터그램 헤더 (8바이트)

![](/assets/img/posts/Computer-Science/Network/2023-11-02-01.png)

- **<span class="shlb">송신지/수신지 포트 번호</span> (2바이트)**
    - 포트 번호는 **애플리케이션(프로세스) 식별**에 사용된다.
    - 클라이언트는 OS가 정한 범위에서 무작위로 할당한 값을 **송신지 포트 번호**로, 애플리케이션별로 정의된 값을 **수신지 포트 번호**로 설정하고 서버에 전송한다.
    - 데이터그램을 받은 서버는 수신지 포트 번호를 보고, 어떤 애플리케이션의 데이터인지 판별해 애플리케이션에 전달한다.
- **<span class="shlb">UDP 데이터그램 길이</span> (2바이트)**
    - UDP 헤더(8바이트) + UDP 페이로드(애플리케이션 데이터), 즉 데이터그램 전체 길이를 나타낸다.
    - 바이트 단위의 값이다.
    - 최솟값은 `8`(UDP 헤더로만 구성된 경우), 최댓값은 **MTU에서 IP 헤더의 길이(20바이트)를 뺀 값**이다.
        
        > **추가 자료**
        >
        > - UDP 페이로드의 크기로 적당한 값은?: [→ 자료1](https://www.gpgstudy.com/forum/viewtopic.php?t=6131)
        > - UDP의 MSS: [→ 자료2](https://ejjoo.github.io/network/2020/01/09/tcp-mss-udp.html)
        > - [→ 자료3](https://eunhyee.tistory.com/244): IPv4 네트워크에서 모든 장비는 최소 576바이트의 데이터그램을 처리할 수 있으므로, 안전하게 IP/UDP 헤더를 고려하여 데이터를 512byte로 전송한다!
        {: .prompt-info}
        
- **<span class="shlb">체크섬</span> (2바이트)**
    - 받아들인 UDP 데이터그램의 손상 여부 정합성 체크에 사용된다.
    - IP 헤더 체크섬과 마찬가지로 1의 보수 연산을 사용한다.
    - 데이터그램을 받은 단말은 정합성 검증에 성공하면 데이터그램을 받는다.

<br>

### 1-2. 포트 번호

> IP 헤더만 있다면 **전 세계 어떤 수신지에서도 IP 패킷을 도달**시킬 수 있다. 하지만 IP 패킷을 받은 단말은 그 IP 패킷을 **어떤 애플리케이션에서 처리하면 좋을지** 알지 못한다. 따라서 트랜스포트 계층에서 애플리케이션을 식별하기 위해 **포트 번호**를 사용한다!

- 애플리케이션 계층에서 동작하는 애플리케이션을 식별하는 **2바이트** 숫자로, `0` ~ `65535`번까지 있다.
- 포트 번호와 애플리케이션은 짝을 지어 묶여있다.
- 송신지 포트 번호는 돌아올 패킷을 위해, 수신지 포트 번호는 서버 애플리케이션을 식별하기 위해 부여한다.
- 세 종류로 분류된다.
    
    | 포트 번호 범위   | 이름      | 용도      | 주요 사용처    |
    | ---------- | ---------- | ----------- | --------- |
    | `0` ~ `1023`                       | system ports                    | 일반적인 서버 애플리케이션<br>(ex. DNS, HTTP, HTTPS, SSH 등) | 서버 애플리케이션<br>(수신지) |
    | `1024` ~ `49151`                   | user ports                      | 제조사의 고유 서버 애플리케이션<br>(ex. MySQL, Tomcat, …)         | 서버 애플리케이션<br>(수신지) |
    | `49152` ~ `53325`                  | dynamic(private) ports         | 클라이언트 측에서 무작위로 할당     | 클라이언트 애플리케이션<br>(송신지) (무작위 할당) |

<br>

---

## 2. TCP (Transmission Control Protocol)

- 메일, 파일 전송, 웹브라우저 등 데이터를 전송의 <span class="ulr">**신뢰성**</span>을 요구하는 애플리케이션에서 사용한다.
- 데이터를 송신하기 전에 <span class="ulr">**TCP 커넥션**</span>을 만든다. 이는 송신 파이프와 수신 파이프라는 두 개의 논리적인 파이프로 구성된다.

<br>

### 2-1. TCP 세그먼트 헤더 (최소 20바이트)

> 신뢰성을 요하기 때문에 UDP보다 헤더가 복잡하다.
> 

![](/assets/img/posts/Computer-Science/Network/2023-11-02-02.png)

- **<span class="shlb">송신지/수신지 포트 번호</span> (2바이트)**
    - 클라이언트는 OS가 결정한 범위 내에서 무작위로 할당한 값을 송신지 포트 번호에, 애플리케이션 별로 정의된 값을 수신지 포트 번호에 설정한다.
    - 서버는 수신지 포트 번호를 보고 어떤 애플리케이션의 데이터인지 판단하고, 그 애플리케이션에 데이터를 전달한다.
- **<span class="shlb">시퀀스 번호</span> (4바이트)**
    - TCP 세그먼트를 올바른 순서로 정렬하기 위해 사용한다.
    - **송신 측 단말**은 애플리케이션에서 받은 데이터의 **각 바이트**에 대해 **초기 시퀀스 번호(ISN)에서 연번**을 부여한다.
    - **수신 측 단말**은 받은 TCP 세그먼트의 **시퀀스 번호를 확인하고, 번호순으로 정렬**해 애플리케이션에 전달한다.
    - 3-way handshake 시 무작위 값이 ISN으로 설정되어 **TCP 세그먼트를 송신할 때마다 송신한 바이트 수만큼** 더해진다.
    - 4바이트로 관리할 수 있는 데이터 양(2^32=4G바이트)을 넘으면 다시 `0`으로 돌아가 증가한다.
- **<span class="shlb">확인 응답 번호</span> (ACK 번호) (4바이트)**
    - 상대에게 ‘다음에 **이 시퀀스 번호 이후의 데이터**를 달라’고 전달하기 위한 필드이다.
    - 컨트롤 비트 `ACK` 플래그가 `1`이 되었을 때만 유효하다.
    - `받아들인 데이터의 가장 마지막 바이트의 시퀀스 번호 + 1`, 즉 `시퀀스 번호 + 애플리케이션 데이터의 길이`가 설정된다.
    
    > - **TCP**는 **시퀀스 번호**와 **확인 응답 번호**를 통해 신뢰성을 확보한다.
    > - 시퀀스 번호 & 확인 응답 번호는 **byte 단위**로 붙인다!!
    {: .prompt-tip}
    
- **<span class="shlb">데이터 오프셋</span> (4비트)**
    - TCP 헤더의 길이를 4바이트 단위로 환산한 값이 들어있다.
        
        > IP 헤더와 마찬가지이다. 따라서 가장 짧은 TCP 헤더의 길이는 20바이트이므로 `5`가 들어간다.
        > 
    - 단말은 이 값을 보고 어디까지 TCP 헤더인지 알 수 있다.
- **<span class="shlb">컨트롤 비트</span> (flag) (8비트)**
    - 커넥션의 상태를 제어하는 필드로, 각 비트를 `0` 또는 `1`로 설정함에 따라 현재 커넥션이 어떤 상태인지 전달한다.
    - ex) `ACK`, `SYN`, `FIN` 등
- **<span class="shlb">윈도우 크기</span> (2바이트)**
    - 받은 데이터 크기를 알리기 위한 필드이다. 즉, 확인 응답을 기다리지 않고 받을 수 있는 데이터 크기이다.
    - 최대 `65535` 바이트까지 알릴 수 있으며, `0`이 더이상 받을 수 없음을 나타낸다.
    - 송신 측 단말은 윈도우 크기가 `0`인 패킷을 받으면 일단 송신을 멈춘다.
- **<span class="shlb">체크섬</span> (2바이트)**
    - 받은 TCP 세그먼트가 손상되지 않았는지 정합성을 체크하기 위해 사용한다.
    - 1의 보수 연산을 사용하며, 검증에 성공하면 세그먼트를 받는다.
- **<span class="shlb">긴급 포인터</span> (2바이트)**
    - 컨트롤 비트의 `URG` 플래그가 `1`로 설정되었을 때만 유효하다.
    - 긴급 데이터가 있을 때, 긴급 데이터를 나타내는 가장 마지막 바이트의 시퀀스 번호가 설정된다.
- **<span class="shlb">옵션</span> (4바이트 단위가 되도록)**
    > TCP에 관련된 확장 기능을 알리기 위한 것으로, 몇 가지 옵션을 옵션 리스트로 나열하는 형태로 구성되어 있다.

    1. **`MSS` (Maximum Segment Size)**
        
        > **MTU vs. MSS**
        >
        > - **MTU (Maximum Transmission Unit):** <span class="shlp">IP 패킷</span>(= <span class="shl">이더넷 페이로드</span>)의 최대 크기
        >     
        >     > 송신 매체에 따라 다르며, 인터넷의 경우(= 이더넷의 MTU 값)에는 기본값이 1,500 바이트이다.
        > 
        > - **MSS (Maximum Segment Size)**: <span class="shl">TCP 페이로드</span>(= 애플리케이션 데이터)의 최대 크기
        > 
        > <span class="shlp">IP 패킷</span> = IP 헤더 + TCP 헤더 + <span class="shl">TCP 페이로드</span>이므로, **<span class="shlp">MTU</span> = IP 헤더 길이 + TCP 헤더 길이 + <span class="shl">MSS</span>**
        {: .prompt-info}
        
        - TCP 페이로드(= 애플리케이션 데이터)의 최대 크기이다.
        - 일반적인 IPv4 환경에서는 <span class="shl">MSS</span> = <span class="shlp">MTU</span> - 40바이트(IP 헤더 + TCP 헤더) 이다.
        - 인터넷의 경우 이더넷(L2) + IPv4(L3) 환경이므로, <span class="shl">MSS</span> = <span class="shlp">1500</span> - 40 = 1460바이트가 된다.
        - 트랜스포트 계층은 **애플리케이션 데이터를 MSS로 구분**하여 **TCP로 캡슐화** 한다.
        - TCP 단말은 3-way handshake 시, 지원하는 **MSS** 값을 서로 알려준다.
    2. **`SACK` (Selective ACK)**
        - SACK이란, 사라진 TCP 세그먼트만을 재전송하는 기능이다.
        - SACK을 사용하지 않으면, 애플리케이션 데이터를 어디까지 받아들였는지를 ACK 번호만으로 판단하기 때문에, 부분적으로 TCP 세그먼트가 사라지면 그 세그먼트 이후의 모든 세그먼트를 재전송해야 한다.
        - SACK를 지원하면 부분적으로 TCP 세그먼트가 사라진 경우, 어디부터 어디까지 받았는지를 옵션 필드로 알릴 수 있다. 따라서 사라진 TCP 세그먼트만 재전송함으로써 효율을 향상시킬 수 있다.

<br>

### 2-2. <span class="shl">[접속 시작 단계]</span> 3-Way Handshake

> 커넥션을 확립한다.
> 

> 커넥션 오픈은 반드시 클라이언트의 `SYN`으로부터 시작한다.
{: .prompt-danger}

1. <span class="pink">클라이언트</span>는 `CLOSED`, <span class="blue">서버</span>는 `LISTEN` 상태이다.
2. <span class="pink">클라이언트</span>는 <span class="pink">**SYN 패킷**</span>을 송신하고, `SYN-SENT` 상태로 이동한다. 그리고 **SYN/ACK 패킷**을 기다린다.
    
    
    | SYN 플래그 | ACK 플래그 | SEQ 번호      | ACK 번호 |
    | ---------- | ---------- | ------------- | -------- |
    | `1`          | `0`          | `x` (무작위 값) | `0`        |
3. <span class="blue">서버</span>는 SYN 패킷을 받은 후 <span class="blue">**SYN/ACK 패킷**</span>을 반환하고, `SYN-RECEIVED` 상태로 이동한다.
    
    
    | SYN 플래그 | ACK 플래그 | SEQ 번호      | ACK 번호 |
    | ---------- | ---------- | ------------- | -------- |
    | `1`          | `1`          | `y` (무작위 값) | `x + 1`    |
4. <span class="pink">클라이언트</span>는 SYN/ACK 패킷을 받은 후 <span class="pink">**ACK 패킷**</span>을 반환하고, `ESTABLISHED` 상태로 이동한다.
    
    > `ESTABLISHED` 상태가 되면 커넥션이 완료되어 애플리케이션 데이터를 송수신할 수 있다.
    > 
    
    | SYN 플래그 | ACK 플래그 | SEQ 번호 | ACK 번호 |
    | ---------- | ---------- | -------- | -------- |
    | `0`          | `1`          | `x + 1`    | `y + 1`    |
5. 서버는 ACK 패킷을 받은 후 `ESTABLISHED` 상태로 이동한다. 이제까지의 SEQ 번호와 ACK 번호에 따라 애플리케이션 데이터의 최초에 부여할 시퀀스 번호를 확정한다.
    
    > `ESTABLISHED` 상태가 되면 커넥션이 완료되어 애플리케이션 데이터를 송수신할 수 있다.
    > 

![](/assets/img/posts/Computer-Science/Network/2023-11-02-03.png){: .w-50}
_ref: [TCP and TLS handshake: What happens from typing in a URL to displaying a website? (Part 2)](https://medium.com/@alysachan830/tcp-and-tls-handshake-what-happens-from-typing-in-a-url-to-displaying-a-website-part-2-243862438cd9)_

<br>

### 2-3. <span class="shl">[접속 확립 단계]</span> 신뢰성 확보: 오류 제어, 흐름 제어, 혼잡 제어

> 실제 애플리케이션 데이터의 교환을 수행한다.
 
#### [1] 흐름 제어(Flow Control)

> 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법 (수신 버퍼, 송신 버퍼)
{: .prompt-tip}

> **수신** 측 단말이 수행

- <span class="ulr">**Stop-and-Wait**</span>
    
    > 본래, 상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 모든 방식을 통칭하는 명칭이다.
    > 
    - 송신 측에서 매번 전송한 패킷에 대해 수신측의 확인 응답을 받아야만 그 다음 패킷을 전송하는 방식이다.
    - 구조가 간단하지만 비효율적이다.
- <span class="ulr">**Sliding Window**</span>
    - Stop-and-Wait의 비효율성을 개선했다.
    - **수신** 측 단말은 **윈도우 크기** 필드를 통해 자신이 받을 수 있는 데이터 양(= **수신 버퍼의 빈 영역의 크기**)을 알린다.
        - 수신 버퍼(윈도우)가 가득 찼다면 윈도우 크기로 `0`을 보낸다.
        - 수신 버퍼가 가득 찼을 때, 애플리케이션에서 데이터를 가져가면 공간이 생긴다. 이 때, 윈도우 크기로 송신 측에 알린다.
    - **송신** 측 단말은 윈도우 크기 내에서는 ACK를 기다리지 않고 연속해서 TCP 세그먼트를 보낸다.
        - 윈도우 크기 `0`을 받으면 송신을 중지한다. 그랬다가 윈도우 크기가 늘어나면 송신을 재개한다.
        
        > 예시
        > 
        > - 송신측에서 `0 1 2 3 4 5 6`을 보낼 수 있는 프레임을 가지고 있고, 데이터 `0 1`을 전송했다면, 윈도우는 `2 3 4 5 6`이 된다.
        > - 만약 수신측으로부터 `0 1`에 대한 ACK를 받으면, 송신측의 윈도우가 우측으로 확장되어 `2 3 4 5 6 x x`가 된다.

#### [2] 오류 제어(Error Control)

> 패킷 유실이 발생했을 때 수행하는 패킷 재전송 기능
{: .prompt-tip}

TCP는 ACK 패킷을 통해 패킷 유실을 감지하고 패킷을 재전송한다. 이때, 기본적으로 **<span class="shl">ARQ</span>(Automatic Repeat Request)**라는 **재전송 기반 오류 제어**를 사용한다.

- <span class="ulr">**Stop-and-Wait ARQ**</span>
    - 흐름 제어의 Stop-and-Wait와 연결된다.
    - 송신 측에서 패킷을 하나 보내고, 수신측에서 수신된 패킷의 에러 유무에 따라 **ACK** 혹은 **NACK**을 보내는 방식이다.
    - 송신측이 **(1) NACK**을 받거나, **(2) 일정 시간(= 재전송 타이머, RTO, Retransmission Timeout)** 동안 수신측으로부터 응답을 받지 못하면 패킷을 재전송한다.
        
        > **RTO**는 RTT(Round Trip Time) 기반 계산식으로 계산된다.
        > 
        > **RTT**란, 네트워크 통신을 하는 두 노드 간 패킷이 왕복하는 데에 소요된 시간이다.
        > 
        > ref: https://brunch.co.kr/@alden/15
        {: .prompt-info}

- <span class="ulr">**Go-Back-N ARQ**</span>
    - 흐름 제어의 Sliding Window와 연결된다.
    - 송신측이 `1 2 3 4 5 6 7 ...`을 보내는데, 수신측으로부터 `ACK(4)`까지만 받고 **(1) 타임아웃**이 발생하거나 **(2) NACK**을 받았다면 `4`번 패킷부터 전부 재전송 한다.
    - 송신측에서는 전송했으나 아직 정상 수신 여부가 확인되지 않은 **패킷의 복사본**을 가지고 있어야 한다.
    - **재전송 해야하는 경우**
        1. 패킷에 오류가 있을 경우:
            - `2`번 패킷에 오류가 있다면 수신측에서는 **`NACK(2)`**를 보낸다.
            - 송신측에서는 `2`번 패킷부터 다시 보낸다.
        2. 순서가 바뀌었을 경우:
            - 수신측에서는 `1`번 패킷 후 `3`번 패킷이 오면 `2`번 패킷을 잃어버렸다고 판단하여 `NACK(2)`를 보내고, `2`번 패킷 이후의 모든 패킷을 폐기한다.
            - 비효율적 → Selective Repeat ARQ
        3. 패킷이 분실되어 수신측에 도달하지 못하는 경우:
            - 송신측에서는 보낸 패킷에 대해 시간이 지나도 `ACK` 및 `NACK`를 받지 못한다.
            - **타임아웃**이 발생하여 마지막으로 `ACK` 받은 데이터부터 다시 송신한다.
                
                > 최근에 `ACK(2)`를 받았으면, `2`번 패킷부터 다시 보낸다.
                > 
- <span class="ulr">**Selective Repeat ARQ**</span>
    - **문제가 발생한 패킷만 재전송**함으로써, Go-Back-N ARQ에서 확인된 마지막 패킷 이후의 모든 패킷을 재전송하는 비효율성을 개선한다.
    - 수신측은 패킷을 새로 재정렬해야 하므로 **별도의 버퍼**를 필요로 한다.

#### [3] 혼잡 제어(Congestion Control)

> 송신측의 데이터 전송과 네트워크 처리 속도 차이로 인한 네트워크 혼잡을 해결하기 위한 기법
{: .prompt-tip}

> **송신** 측 단말이 수행

- 네트워크가 혼잡해지면 패킷 유실이나 전송 지연이 발생한다.
- **패킷 송신 수를 제어함**으로써 네트워크가 혼잡해지지 않도록 하며, 이 **패킷 송신 수**를 **혼잡 윈도우(`cwnd`)**라고 한다.
    
    > 혼잡하면 혼잡 윈도우를 줄이고, 혼잡하지 않으면 늘린다.
    > 
- <span class="ulr">**AIMD (Additive Increase Multicative Decrease)**</span>
    - 합 증가 / 곱 감소 알고리즘
    - 처음에 패킷 하나를 보내고, 문제 없이 도착한다면 **`cwnd`를 1씩 증가**시키며 전송한다. 만약 패킷 전송에 실패(**NACK**)하거나 **타임아웃**이 발생하면 **`cwnd`를 절반으로 감소**한다.
    - **장점**: 여러 송신측이 있는 상황에서 송신측이 하나 추가될 때, 처음에는 `cwnd`가 작아 불리하지만 나중에는 평형을 이루게 되어 공평해진다.
    - **단점**: 초기에 높은 대역폭을 사용하지 못하고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못하여 혼잡해지고 나서야 대역폭을 줄이는 형태이다.
        
        > **대역폭**
        > 
        > 어떤 매체나 기기를 경유하여 정보를 전송할 때의 전송량
        {: .prompt-info}

- <span class="ulr">**Slow Start**</span>
    - 초기에 전송 속도를 올리는 데에 시간이 소요되는 AIMD를 보완한다.
    - `cwnd`를 2배씩 늘리고, 혼잡 현상이 발생하면 1로 줄인다.
    - 처음에는 네트워크 수용량을 예측할 수 있는 정보가 없지만, 시간이 지나면서 혼잡 현상이 발생했던 `cwnd` 크기를 알 수 있다. 해당 크기의 절반(= 임계값)까지는 이전처럼 2배씩 `cwnd`를 증가시키고, 이후부터는 1씩 증가시키는 방식이다.
    - 사용 가능한 정책
        1. <span class="ulg">**혼잡 회피 (congestion avoidance)**</span>
            - `cwnd`를 2배씩 늘리다가, **임계 지점부터는 1씩 증가**시킨다.
            - 패킷이 일정 시간동안 `ACK`, `NACK`을 받지 못하는 경우, **혼잡 상황**이라고 간주한다.
            - 혼잡이 발생하면 **`cwnd`를 1로** 줄이고, **임계값을 절반으로** 줄인다.
        2. <span class="ulg">**빠른 회복 (fast recovery)**</span>
            - 혼잡 발생 시 **`cwnd`를 1이 아닌 절반으로 줄이고**, 1씩 증가시킨다.
            - 한 번 혼잡이 발생한 후에는 **AIMD**로 작동한다.
        3. <span class="ulg">**빠른 재전송 (fast retransmit)**</span>
            - 수신측에서 순서 상 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 `ACK` 패킷을 보낸다. 이때, 순서대로 잘 도착한 마지막 패킷의 순번을 `ACK` 패킷에 실어서 보낸다. 따라서 중간에 패킷 하나가 손실되면, 송신측에서는 순번이 중복된 `ACK` 패킷을 받게 된다.
                
                > ex) 수신측에서 `1 2 3 6 4 5` 순서로 수신한다면, 송신측에 `ACK(4)`, `ACK(4)`, `ACK(4)`를 보내게 된다.
                > 
            - 이처럼 중복된 순번의 `ACK` 패킷을 3개 받으면 재전송한다. 또한, 이러한 상황을 약간의 혼잡이 발생한 것으로 간주하여 `cwnd`의 크기를 절반으로 줄인다.

<br>

### 2-4. <span class="shl">[접속 종료 단계]</span> 4-Way Handshake

커넥션 종료 처리를 수행한다. 종료 처리에 실패하면 불필요한 커넥션이 단말에 남으므로 오픈 처리보다 더 신중하게 진행한다.

> 커넥션 클로즈는 클라이언트, 서버 어느 쪽에서든 `FIN`을 보내면서 시작한다. 여기에서는 클라이언트 측에서 `FIN`을 보내는 상황을 다룬다.
{: .prompt-danger}

1. <span class="pink">클라이언트</span>는 애플리케이션으로부터 클로즈 처리 요구가 들어오면, <span class="pink">**FIN/ACK 패킷**</span>을 송신하고, `FIN-WAIT1` 상태로 이동한다.
    
    
    | FIN 플래그 | ACK 플래그 | SEQ 번호 | ACK 번호 |
    | ---------- | ---------- | -------- | -------- |
    | `1`          | `1`          | `x`        | `y`        |
2. <span class="blue">서버</span>는 FIN/ACK 패킷을 받은 후 <span class="blue">**ACK 패킷**</span>을 송신하고 **애플리케이션에 대해 클로즈 처리를 의뢰**하며, `CLOSE-WAIT` 상태로 이동한다.
    
    
    | FIN 플래그 | ACK 플래그 | SEQ 번호 | ACK 번호 |
    | ---------- | ---------- | -------- | -------- |
    | `0`          | `1`          | `y`        | `x + 1`    |
3. <span class="pink">클라이언트</span>는 ACK 패킷을 받고 `FIN-WAIT2` 상태로 이동한다.
4. <span class="blue">서버</span>는 **애플리케이션으로부터 클로즈 처리 요청**이 있으면 <span class="blue">**FIN/ACK 패킷**</span>을 송신하고, `LAST-ACK` 단계로 이동한다.
    
    
    | FIN 플래그 | ACK 플래그 | SEQ 번호 | ACK 번호 |
    | ---------- | ---------- | -------- | -------- |
    | `1`          | `1`          | `y`        | `x + 1`    |
5. <span class="pink">클라이언트</span>는 FIN/ACK 패킷을 받은 후 <span class="pink">**ACK 패킷**</span>을 반송하고, `TIME_WAIT` 상태로 이동한다.
    
    > `TIME_WAIT` 상태: 혹시라도 늦게 도착할지 모를 ACK 패킷을 기다린다.
    > 
    
    | FIN 플래그 | ACK 플래그 | SEQ 번호 | ACK 번호 |
    | ---------- | ---------- | -------- | -------- |
    | `0`          | `1`          | `x + 1`    | `y + 1`    |
6. <span class="blue">서버</span>는 ACK 패킷을 받고 `CLOSED` 상태로 이동하고, 커넥션 삭제 및 자원을 해제한다.
    
    > 패시브 클로즈 종료
    > 
7. <span class="pink">클라이언트</span>는 타임아웃이 끝나면 `CLOSED` 상태로 이동하고, 커넥션 삭제 및 자원을 해제한다.
    
    > 액티브 클로즈 종료
    > 

![](/assets/img/posts/Computer-Science/Network/2023-11-02-04.png){: .w-50}
_ref: [TCP 4-Way Termination Handshake](https://www.linkedin.com/pulse/tcp-4-way-termination-handshake-ibraham-ajazz/)_

<br>

---

## 3. 방화벽

### 3-1. 개요

- 트랜스포트 계층에서 동작하는 기기로, **`5 tuple`(송신지/수신지 IP 주소, 트랜스포트 계층 프로토콜, 송신지/수신지 포트 번호)로 커넥션을 식별**하고 송신을 제어한다.
- 미리 설정한 규칙에 따라 통신의 허용 여부를 식별하고 시스템을 보호한다.
- 이러한 통신 제어 기능을 **스테이트풀 인스펙션**이라 하며, 다음을 통해 통신을 제어한다.
    - <span class="shlb">**필터링 규칙**</span>: 허가할 통신과 거부할 통신의 형태를 정의한다.
        
        > ex) `192.168.1.0/24`라는 사내 LAN에 있는 단말에서 인터넷으로의 웹 접근을 허가하는 경우
        > 
        > 
        > ![](/assets/img/posts/Computer-Science/Network/2023-11-02-05.jpeg)
        > 
        > 단순히 HTTP 뿐만 아니라, HTTP를 SSL/TLS로 암호화하는 HTTPS, 도메인 이름을 IP 주소로 변환할 때 사용하는 DNS도 함께 염두해두어야 한다.
        > 
    - <span class="shlb">**커넥션 테이블**</span>: 방화벽이 자신을 경유하는 커넥션 정보를 관리하는 테이블이다.
        - 송신지/수신지 IP 주소, 프로토콜, 송신지/수신지 포트 번호, 커넥션 상태, 아이들 타임아웃 등 각종 요소로 만들어지는 복수의 커넥션 엔트리로 구성된다.

<br>

### 3-2. 방화벽이 <span class="ulg">UDP 데이터그램</span>을 처리하는 방법

1. 방화벽은 클라이언트 측에 있는 인터페이스에서 **UDP 데이터그램**을 받아들여, **필터링 규칙**과 조합한다.
2. 들어온 UDP 데이터그램의 액션이
    - **“허가”인 엔트리인 경우,**
        1. **커넥션 테이블**에 커넥션 엔트리를 추가한다.
        2. 커넥션 엔트리에 대응하는 **반환 통신**을 허가하는 **필터링 규칙**을 추가한다.
            
            > 반환 통신 = 커넥션 엔트리의 송신지 ↔ 수신지 반전
            > 
        3. 서버에 UDP 데이터그램을 전송한다.
    - **“거부”인 엔트리인 경우,**
        1. **커넥션 테이블**에 커넥션 엔트리를 추가하지 않는다.
        2. 클라이언트에 **ICMP 패킷**(Destination Unreachable)을 반환한다.
    - **“드롭”인 엔트리인 경우**, 아무것도 하지 않는다. (보안 관점에서 바람직) (Silently Discard)
3. 액션이 “허가”인 엔트리인 경우, 서버로부터 **반환 통신(송신지 ↔ 수신지 반전)**이 발생한다. 방화벽은 서버 측에 있는 인터페이스에서 반환 통신을 받아들이면
    1. 이전에 추가한 **필터링 규칙**을 사용해 허가 제어를 실행한다.
    2. 클라이언트에 전송한다.
    3. **커넥션 테이블** 엔트리의 **아이들 타임**을 `0`초로 초기화한다.
4. 통신이 끝나면 **방화벽**은 **커넥션 테이블** 엔트리의 **아이들 타임을 증가**시킨다. **아이들 타임아웃**이 경과하면 **커넥션 엔트리**와 관련된 **필터링 규칙**을 모두 삭제한다.

<br>

### 3-3. 방화벽이 <span class="ulg">TCP 세그먼트</span>를 처리하는 방법

> UDP에서와 마찬가지로 **필터링 규칙**과 **커넥션 테이블**을 이용한다. 단, **커넥션 테이블**에 **커넥션 정보를 나타내는 열**이 추가되고, 그 정보를 기반으로 커넥션 엔트리를 관리한다.

1. 방화벽은 클라이언트 측에 있는 인터페이스로 **`SYN` 패킷**을 받아 필터링 규칙과 조합한다.
2. 들어온 TCP 세그먼트의 액션이
    - **“허가”인 엔트리인 경우,**
        1. **커넥션 테이블**에 커넥션 엔트리를 추가한다.
        2. 커넥션 엔트리에 대응한 **반환 통신**을 허가하는 **필터링 규칙**을 동적으로 추가한다.
        3. 서버에 TCP 세그먼트를 전송한다.
    - **“거부”인 엔트리인 경우,**
        1. **커넥션 테이블**에 커넥션 엔트리를 추가하지 않는다.
        2. 클라이언트에 **RST 패킷**을 반환한다.
    - **“드롭”인 엔트리인 경우**, 아무것도 하지 않는다. (보안 관점에서 바람직) (Silently Discard)
        1. 클라이언트는 `SYN/ACK` 패킷이 돌아오지 않으면 OS나 그 버전별로 정해진 간격으로, 정해진 횟수만큼 `SYN`을 계속 재전송한다.
3. 액션이 “허가”인 엔트리인 경우, 서버로부터 **`SYN/ACK` 패킷**을 **반환 통신**한다. 방화벽은 서버 측에 있는 인터페이스에서 반환 통신을 받아들이면
    1. 이전에 추가한 **필터링 규칙**을 사용해 허가 제어를 실행한다.
    2. 클라이언트에 전송한다.
    3. **커넥션 테이블** 엔트리의 **커넥션 엔트리 상태**를 `SYN-SENT` → `ESTABLISHED`로 업데이트하고, **아이들 타임**을 `0`초로 초기화한다.
4. 애플리케이션 데이터 전송이 끝나면 **4-way hanshake**에 의한 클로즈 처리가 실행된다.
    - 방화벽은 클라이언트-웹서버 사이에서 교환되는 `FIN/ACK` → `ACK` → `FIN/ACK` → `ACK`라는 패킷의 흐름을 보고 **커넥션 엔트리를 삭제**하고, **반환 통신용 필터링 규칙**도 삭제한다.
    - 또한, 만약 커넥션이 정상적으로 클로즈될 수 없는 경우일 때를 대비하여 **아이들 타임이 타임아웃**되면 커넥션 엔트리와 반환 통신용 필터링 규칙을 삭제한다.

<br>

---

## References

- "그림으로 공부하는 TCP/IP 구조(미야타 히로시 저)", Ch5. 트랜스포트 계층
- <https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Network/TCP.md>
- <https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/>
- <https://evan-moon.github.io/2019/11/26/tcp-congestion-control/>
- <https://github.com/GimunLee/tech-refrigerator/blob/master/Network/흐름제어%20%26%20혼잡제어%20%26%20오류제어.md>
- <https://velog.io/@jsj3282/TCP-흐름제어혼잡제어-오류제어>
- <https://eunhyee.tistory.com/248>
- <https://eunhyee.tistory.com/249>
- <https://velog.io/@jkjan/네트워크-TCP>
